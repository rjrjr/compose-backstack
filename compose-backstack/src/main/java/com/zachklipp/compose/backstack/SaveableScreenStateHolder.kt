package com.zachklipp.compose.backstack

import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.runtime.currentCompositeKeyHash
import androidx.compose.runtime.key
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.SaveableStateHolder
import androidx.compose.runtime.saveable.rememberSaveableStateHolder

@Composable internal fun <T> rememberSaveableScreenStateHolder(): SaveableScreenStateHolder<T> {
  val stateHolder = rememberSaveableStateHolder()
  return remember { SaveableScreenStateHolder(stateHolder) }
}

/**
 * Wrapper around a [SaveableStateHolder] that helps generate saveable (bundleable) keys for use
 * with the holder and removes keys after they're removed from the backstack.
 *
 * Because keys passed to [SaveableStateHolder.SaveableStateProvider] must be saveable (bundleable),
 * we can't just pass the backstack keys directly – they may not be bundleable. However, we ask
 * Compose to generate keys from the items using the [key] function. We can then derive an [Int] key
 * that will always be consistent for a given backstack keys, even across process restarts, and use
 * that for the saveable registry. This works as long as backstack keys implement hashcode
 * correctly, which they must to be supported by backstack anyway.
 */
internal class SaveableScreenStateHolder<T>(private val holder: SaveableStateHolder) {

  /**
   * Associates compose-generated "composite key hashes" with backstack items.
   */
  private val stateKeysByScreenKey = mutableMapOf<T, Int>()

  /**
   * Compose [content] for the (potentially non-bundleable) value [screenKey] so that any
   * `rememberSaveable`s in [content] will be saved and restored.
   *
   * Wraps [SaveableStateHolder.SaveableStateProvider].
   */
  @Composable fun SaveableStateProvider(screenKey: T, content: @Composable () -> Unit) {
    val stateKey = currentCompositeKeyHash

    // Once the composition has been committed, associate the item with the holder key generated
    // from the composition. This is so that when item is removed from the backstack,
    // removeStaleKeys knows which actual state key to remove from the holder.
    // This must be done in a SideEffect since keysByItem is not a snapshot state object.
    // The only synchronization requirement is that this key is added to the map before
    // removeStaleKeys is called after the item is removed from the backstack.
    SideEffect {
      val existingStateKey = stateKeysByScreenKey[screenKey]
      if (existingStateKey == null) {
        stateKeysByScreenKey[screenKey] = stateKey
      } else if (existingStateKey != stateKey) {
        error(
          "Expected currentCompositeKeyHash to not change for Backstack items. " +
              "Is the caller wrapped in a key() {}?"
        )
      }
    }

    // This function will automatically save and restore saveable state when it's skipped or
    // composed again. We have to use the compose-generated int stateKey, even though this function
    // accepts Any, because it doesn't _actually_ accept Any – it only accepts values that are
    // saveable, and the backstack item may not be saveable.
    holder.SaveableStateProvider(stateKey, content)
  }

  /**
   * Removes any keys that were generated by [SaveableStateProvider] but are not present in
   * [backstack] from the [SaveableStateHolder]
   *
   * Must only be called from a [SideEffect].
   */
  fun removeStaleKeys(backstack: List<T>) {
    stateKeysByScreenKey.iterator().apply {
      while (hasNext()) {
        val (screenKey, stateKey) = next()
        if (screenKey !in backstack) {
          holder.removeState(stateKey)
          remove()
        }
      }
    }
  }
}
